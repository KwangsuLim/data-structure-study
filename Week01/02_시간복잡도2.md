# 시간복잡도 2

## 자료구조, 알고리즘의 시간복잡도
```pseudocode
    algorithm ArrayMax(A, n):
        input: n개의 정수를 갖는 배열 A
        output: A의 수 중에서 최대값 리턴
        currnetMax = A[0]
        for i = 1 to n-1 do
        if cuurentMax < A[i]:
            currnentMax = A[i]
        return currentMAx
```

### A = [], n: input size  
1. 모든 입력에 대하여 기본연산 횟수를 더한 후 평균 &rightarrow; 현실적으로 불가능
2. 가장 안 좋은 입력(worstcase input)에 대한 기본연산 횟수를 측정: worstcase time complexity &rightarrow; 어떤 입력에 대해서도 worstcase time complexity보다 수행시간이 크지않다.

**일반적인 시간복잡도의 정의 : 알고리즘 수행시간 = 최악의 입력에 대한 기본연산 횟수**  
**worstcase input: A = [2,5,7,9,12,15,35]**

**(초기값 설정 1번) + (if문: 비교문 1번, 초기화1번 &rightarrow; 2번) * (n-1번의 for문) = $2n-1$**

- 알고리즘의 수행시간 T(n) = 2n-1
- n=6일때, 최악의 경우 T(6)=11번의 연산

## 예시
```
algorithm sum1(A, n):
    sum=0                      #1
    for i = 0 to n-1 do        #n번
        if A[i] % 2 == 0:      #2번
            sum += A[i]        #2번
    return sum
```

1. sum=0 **대입연산**
2. if A[i] % 2 == 0: **두번의 연산실행**
3. sum += A[i] **두번의 연산실행** 
4. for문 **n번의 연산실행**
5. $4n + 1$

<br>  

- A 모든 값이 짝수일 경우 최악의 경우입력
- $T(n) = 4n + 1$
- 일차식 : n이 커지면 n에 비례해서 커진다

<br>

```
algorithm sum2(A,r):
    sum=0                           # 1
    for i=0 to n-1 do               # n번
        for j=i to n-1 do           # n(n+1)2
            sum += A[i] * A[j]      # 3번
    return sum
```

1. sum=0 **대입연산**
2. for i=0 to n-1 do **n번의 연산**
3. for j=i to n-1 do
    | i | j |
   | --- | --- |
   | 0 | n |
   | 1 | n-1 |
   | 2 | n-2 |
   | ... | ... |
   | n-1 | 1 |  
   
   $1 + 2 + 3 +  ... + n$ = $\frac{n(n+1)}{2}$ 번의 연산   
4. sum += A[i] * A[j] **3번의 연산**  

<br>  

- 모든 경우가 최악의 경우
- $T(n) = \tfrac{3}{2} \, n(n+1) + 1$
- $T(n) = \tfrac{3}{2} n^2 + \tfrac{3}{2} n + 1$
- 이차식 : n이 커지면 n의 제곱에 비례해서 커진다