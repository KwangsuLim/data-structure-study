# queue

## queue
### FIFO 규칙의 순차적 자료구조

```py
enqueue(5)     #[5]
enqueue(-2)    #[5, -2]
dequeue()      #[-2]      return 5
enqueue(10)    #[-2, 10]  
dequeue()      #[10]      return -2
```
<br>

```python
class Queue:
    def __init__(self):
        self.items = []
        self.front_index = 0  #dequeue 할 때 참조할 앞쪽 위치

    def enqueue(self, val):    #큐의 뒤쪽에 새로운 원소 추가
        self.items.append(val)    # O(1)

    def dequeue(self):    
        if self.front_index == len(self.items): #이미 원소를 다 꺼냈으면
            print("Q is empty")
            return None
        else:
            x = self.items[self.front_index]
            self.front_index += 1    #front_index를 1 추가한다.
            return x

```
- **enqueue**는 리스트 append()사용
- **dequeue**는 front_index를 증가시켜서 앞에서 빼는 효과를 만듦
- 

#### dequeue 
- stack + queue
- appendleft, append
- popleft, pop
- python.deque 클래스 제공됨

### 큐 활용 예: Josephus problem
[Josephus problem](https://ko.wikipedia.org/wiki/%EC%9A%94%EC%84%B8%ED%91%B8%EC%8A%A4_%EB%AC%B8%EC%A0%9C)

```python
Josephus(n, k):
    return 최종 생존자의 번호
```

[Josephus problem Baekjun](hhttps://www.acmicpc.net/problem/11866)